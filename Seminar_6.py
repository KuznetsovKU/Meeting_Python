# Задача №39. Даны два массива чисел. Требуется вывести те элементы первого массива (в том порядке,
#             в каком они идут в первом массиве), которых нет во втором массиве.
#             Пользователь вводит число N - количество элементов в первом массиве, затем N чисел - элементы массива.
#             Затем число M - количество элементов во втором массиве. Затем элементы второго массива

# def fill_array(size):
#     output_array = []
#     for _ in range(size):
#         output_array.append(int(input('Введите очередной элемент массива: ')))
#     return output_array
#
#
# array_1_size = int(input('Введите количество элементов первого массива: '))
# array_1 = fill_array(array_1_size)
# array_2_size = int(input('Введите количество элементов второго массива: '))
# array_2 = fill_array(array_2_size)
#
# # for i in array_1:         # не самый эффективный вариант из-за квадратичной сложности
# #     if not i in array_2:  # оператор in проходит по всему списку / массиву
# #         print(i, end='\n')
#
# array_2 = set(array_2)  # вариант быстрее, т.к. поиск во множестве и в словаре происходит мгновенно
# for i in array_1:
#     if i not in array_2:
#         print(i, end='\n')

print()


# Задача №41. Дан массив, состоящий из целых чисел. Напишите программу, которая в данном массиве определит
#             количество элементов, у которых два соседних и, при этом, оба соседних элемента меньше данного.
#             Сначала вводится число N — количество элементов в массиве Далее записаны N чисел — элементы массива.
#             Массив состоит из целых чисел.

# def fill_array(size):
#     output_array = []
#     for _ in range(size):
#         output_array.append(int(input('Введите очередной элемент массива: ')))
#     return output_array
#
#
# array_1_size = int(input('Введите количество элементов массива: '))
# array_1 = fill_array(array_1_size)
# counter = 0
#
# for i in range(1, array_1_size - 1):
#     if array_1[i] > array_1[i - 1] and array_1[i] > array_1[i + 1]:
#         counter += 1
#
# print(counter)

print()

# Задача №43. Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента,
#             равные друг другу образуют одну пару, которую необходимо посчитать. Вводится список чисел.
#             Все числа списка находятся на разных строках.

# def fill_array():
#     output_array = []
#     while True:
#         element = (int(input('Введите очередной элемент массива: ')))
#         if element != 0:
#             output_array.append(element)
#         else:
#             break
#     return output_array
#
#
# array = fill_array()
# pair_counter = 0
# # # for i in range(len(array)):  # решение, соответствующее условию задачи
# # #     for j in range(i + 1, len(array)):
# # #         if array[i] == array[j]:
# # #             pair_counter += 1
# #
# # frequency_dict = {}  # решение, если считать только полные пары без дублирования (3 эл = 1 пара, 4 эл = 2 пары)
# # for i in array:
# #     frequency_dict[i] = frequency_dict.get(i, 0) + 1
# # for value in frequency_dict.values():
# #     pair_counter += value // 2
#
# for i in range(1, len(array)):  # решение, если парой считать только одинаковые элементы, идущие подряд
#     if array[i] == array[i - 1]:
#         pair_counter += 1
#
# print(pair_counter)

print()

# Задача №45. Два различных натуральных числа n и m называются дружественными, есnли сумма делителей числа
#             (включая 1, но исключая само n) равна числу m и наоборот. Например, 220 и 284 – дружественные числа.
#             По данному числу k выведите все пары дружественных чисел, каждое из которых не превосходит k.
#             Программа получает на вход одно натуральное число k, не превосходящее 10**5.
#             Программа должна вывести все пары дружественных чисел, каждое из которых не превосходит k.
#             Пары необходимо выводить по одной в строке, разделяя пробелами. Каждая пара должна быть выведена только один раз
#             (перестановка чисел новую пару не дает).

number = int(input('Введите число: '))

def find_div_sum(number):
    amount = 0
    for i in range(1, number // 2 + 1):
        if number % i == 0:
            amount += i
    return amount

# def find_pairs(number):
pairs_dict = {}                               # ключ словаря = сумма делителей некоего числа
# for i in range(1, number + 1):                # проходим по числам от 1 до number, включая number
#     if i in pairs_dict:                       # если число уже есть в словаре в качестве ключа (см. выше)
#         if find_div_sum(i) == pairs_dict[i]:  # и если сумма делителей числа == значению по ключу
#             print(i, pairs_dict[i])           # выводим пару, т.к. "дружественность" подтверждена
#     pairs_dict[find_div_sum(i)] = i           # дополняем словарь новой парой "ключ : значение"

for i in range(1, number + 1):                  # проходим по числам от 1 до number, включая number
    # заполняем словарь: ключ = число от 1 до number, включая number => избегаем перезаписываний
    pairs_dict[i] = pairs_dict.get(i, find_div_sum(i))

result_dict = {}  # объявляем результирующий словарь
for i in pairs_dict:                              # проходим по ключам pairs_dict
    if i in pairs_dict.values():                  # если ключ присутствует в значениях
        if i == find_div_sum(pairs_dict[i]):      # если ключ равен сумме делителей значения
            if i != pairs_dict[i]:                # если ключ НЕ равен своему значению
                if i not in result_dict.values(): # если ключа нет в значениях результирующего словаря
                    result_dict[i] = result_dict.get(i, pairs_dict[i])  # записываем в результирующий словарь
                    print(i, pairs_dict[i])       # выводим пару, т.к. "дружественность" подтверждена
